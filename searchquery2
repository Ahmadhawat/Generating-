#!/usr/bin/env python3
import argparse
import sqlite3
from pathlib import Path
from typing import List
import numpy as np
from sentence_transformers import SentenceTransformer
import faiss

def normalize(vecs: np.ndarray) -> np.ndarray:
    norms = np.linalg.norm(vecs, axis=1, keepdims=True) + 1e-12
    return vecs / norms

class E5QueryEncoder:
    def __init__(self, device=None):
        self.model = SentenceTransformer("intfloat/multilingual-e5-base", device=device)
    def encode(self, text: str) -> np.ndarray:
        q = f"query: {text.strip() if text else ''}"
        v = self.model.encode([q], convert_to_numpy=True, show_progress_bar=False)
        return normalize(v.astype("float32"))

def load_faiss(index_path: Path) -> faiss.Index:
    if not index_path.exists():
        raise FileNotFoundError(f"FAISS index not found at {index_path}")
    return faiss.read_index(str(index_path))

def open_sqlite(db_path: Path) -> sqlite3.Connection:
    if not db_path.exists():
        raise FileNotFoundError(f"SQLite DB not found at {db_path}")
    conn = sqlite3.connect(db_path)
    conn.row_factory = sqlite3.Row
    return conn

def fetch_block(conn: sqlite3.Connection, faiss_id: int) -> sqlite3.Row:
    rowid = faiss_id + 1  # 1-based in SQLite
    cur = conn.execute("SELECT rowid as row_id, * FROM blocks WHERE rowid = ?", (rowid,))
    return cur.fetchone()

def truncate(s: str, n: int) -> str:
    if not s:
        return ""
    return s if len(s) <= n else s[:n-1] + "â€¦"

def save_html_hit(out_dir: Path, rank: int, row: sqlite3.Row):
    out_dir.mkdir(parents=True, exist_ok=True)
    fname = out_dir / f"hit_{rank:02d}_{row['doc_id']}_{row['block_id']}.html"
    with open(fname, "w", encoding="utf-8") as f:
        f.write(f"<!doctype html><meta charset='utf-8'><title>{row['title'] or ''}</title>\n")
        f.write(row["html_clean"] or "")
    return fname

def search(db_dir: Path, query: str, k: int, device=None, save_html=False):
    index_path = db_dir / "index.faiss"
    db_path = db_dir / "metadata.db"

    index = load_faiss(index_path)
    conn = open_sqlite(db_path)
    encoder = E5QueryEncoder(device=device)
    qvec = encoder.encode(query)

    scores, ids = index.search(qvec, k)
    ids, scores = ids[0], scores[0]

    print("\n=== Search Results ===")
    print(f"Query: {query}\n")
    print(f"{'Rank':<6}{'Score':<8}{'File (doc_id)':<25}{'Title':<40}{'Snippet'}")
    print("-" * 110)

    for rank, (fid, sc) in enumerate(zip(ids, scores), start=1):
        if fid < 0:
            continue
        row = fetch_block(conn, fid)
        title = truncate(row["title"], 38)
        snippet = truncate(row["text"], 70).replace("\n", " ")
        print(f"{rank:<6}{sc:7.3f}  {truncate(row['doc_id'],23):<25}{title:<40}{snippet}")

        if save_html:
            save_html_hit(db_dir / "hits", rank, row)

    if save_html:
        print(f"\nSaved HTML snippets in: {db_dir / 'hits'}")

def main():
    ap = argparse.ArgumentParser(description="Simple search viewer for the HTML vector DB.")
    ap.add_argument("db_dir", type=str, help="Folder with index.faiss and metadata.db")
    ap.add_argument("--q", "--query", dest="query", required=True, help="Search query")
    ap.add_argument("-k", type=int, default=5, help="Top K results")
    ap.add_argument("--device", type=str, default=None, help="cpu or cuda")
    ap.add_argument("--save-html", action="store_true", help="Save hit HTML files")
    args = ap.parse_args()

    search(Path(args.db_dir), args.query, args.k, device=args.device, save_html=args.save_html)

if __name__ == "__main__":
    main()